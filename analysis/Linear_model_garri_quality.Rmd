---
title: "Garri Functional Quality"
output: pdf_document
date: "2023-02-10"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r Check that I have the packages}
packages_used <- c("workflowr", "tidyverse", "ggplot2", "here", "stringr" , "sommer","lme4","metan", "rrBLUP","FactoMineR","corrplot")
ip <- installed.packages()
all_packages_installed <- TRUE
for (package in packages_used){
  if (!(package %in% ip[,"Package"])){
    print(paste("Please install package", package))
    all_packages_installed <- FALSE
  } else {
    library(package, character.only = T) # load required package
  } # end else statement
}#END packages_used
if (!all_packages_installed) stop("Need to install packages")

```


```{r Use here package}
require(here)
here::i_am("analysis/Linear_model_garri_quality.Rmd")
```

```{r Pull in the data}
Oto_22_func <- read.csv(here::here("data", "OTOBI_2022PYT_FUNCTIONAL.csv"), head=T)

# Oto_22_func<-read.csv("/Users/ca384/Documents/ChinedoziRepo/GarriQuality/data/OTOBI_2022PYT_FUNCTIONAL.csv", head=T) # data for Otobi wit swelling power, swelling indx, bulk denSIty and water absorbing capacity for 2022
Umu_22_func <- read.csv(here::here("data/UMU_2022_PYT_FUNCTIONAL.csv"), head=T)
# Umu_22_func<-read.csv("/Users/ca384/Documents/ChinedoziRepo/GarriQuality/data/UMU_2022_PYT_FUNCTIONAL.csv",head=T)# data for Umudike wit swelling power, swelling index, bulk denSIty and water absorbing capacity for 2022

str(Oto_22_func)
str(Umu_22_func)
Oto_22_func$Genotype<-as.factor(Oto_22_func$Genotype)
Oto_22_func$wac.<-as.numeric(Oto_22_func$wac.)
Umu_22_func$Genotype<-as.factor(Umu_22_func$Genotype)
head(Umu_22_func)
head(Oto_22_func)
str(Oto_22_func)
str(Umu_22_func)
summary(Oto_22_func)
summary(Umu_22_func)
```

```{r creating plots}
boxplot(Oto_22_func$wac. , main="Water absorbing capacity of garri OTO",ylab = "WAC",xlab="Genotypes")

boxplot(Umu_22_func$wac. , main="Water absorbing capacity of garri UMU",ylab="WAC", xlab="Genotypes") #Removing outliers using the boxplot method

boxplot(Oto_22_func$swelling.index, xlab="Genotypes", ylab="SI")
boxplot(Oto_22_func$swelling.power, ylab="SP",xlab="Genotypes")
boxplot(Oto_22_func$wac.,ylab="WAC", xlab="Genotypes")
boxplot(Oto_22_func$Bulk.Density, xlab="Genotypes", ylab="Bulk density")

```



```{r rename a column and adding new colun for otobi and umudike}
#Using rename() in dplyr

colnames(Oto_22_func)
colnames(Umu_22_func)
Umu_22_func <- Umu_22_func %>% 
       rename(Bulk.Density = AverageBD) # rename bulk density

Umu_22_func <- Umu_22_func %>% 
       rename(WAC= wac.) # rename wac. to WAC
Umu_22_func <- Umu_22_func %>% 
       rename(swelling.index= Swelling.index) # rename wac. to WAC

Oto_22_func <- Oto_22_func %>% 
       rename(WAC= wac.) # rename wac. to WAC for otobi
```

```{r remove column sn and add column for year and location}
#remove column, sn and add column for year and location
Umu_22_func <-Umu_22_func %>%
  add_column(location = "Umudike", year="2022") # add column with location and year for Umudike

#Umu_22_func <- subset(Umu_22_func, select=-c(sn)) # Remove the sn

Umu_22_func <- Umu_22_func %>% relocate(location, year) # change the position of the location and year

Oto_22_func <- Oto_22_func %>%
  add_column(location = "Otobi", year="2022") %>% relocate(location, year)
# change the position of location and year from last column to the first column

Oto_22_func <- Oto_22_func %>% dplyr::select("location", "year",  "Genotype","swelling.index", "swelling.power", "WAC", "Bulk.Density") # select the needed columns

Umu_22_func <- Umu_22_func %>% dplyr:: select("location", "year",  "Genotype", "swelling.index", "swelling.power", "WAC", "Bulk.Density") # select the needed columns
 
```


```{r joining the two data frames}

#joining the two data frames
Umu_oto_22 <- rbind(Oto_22_func, Umu_22_func)

Umu_oto_22$location <- as.factor(Umu_oto_22$location)
Umu_oto_22$year <- as.factor(Umu_oto_22$year)

plot(Umu_oto_22)
colnames(Umu_oto_22)
```


```{r importing 2019 functional properties data and renaming column}
#importing 2019 functional properties data and renaming column
# change Oto and Umu_19 to Umu_20
Oto_19 <- read.csv(here::here("data", "functional-otobi2019_2020.csv"), head=T)

Umu_19 <- read.csv(here::here("data", "Umu_func_pyt2019_2020.csv"), head=T)

colnames(Oto_19)
colnames(Umu_19)

Oto_19 <- Oto_19 %>% 
       rename(Genotype= sample_id)

Umu_19 <- Umu_19 %>% 
       rename(Genotype= Genotypes)

Umu_19 <- Umu_19 %>% 
       rename(Moisture = X.moisture)

Umu_19 <- Umu_19 %>% 
       rename(Dry.Matter =X..Dry.Matter)

Oto_19 <- Oto_19 %>% 
       rename(swelling.index=Swelling.Index..final.initial.)

Oto_19 <- Oto_19 %>% 
       rename(swelling.power= SP)

Oto_19 <- Oto_19 %>% 
       rename(Bulk.Density= Bulk.Density..g.ml.)

colnames(Oto_19)
colnames(Umu_19)
dim(Oto_19)

dim(Umu_19)
```


```{r select the need column from Oto_19 and Umu_19, Add year 2019, change the stucture of the data}
#select the need column from Oto_19 and Umu_19, Add year 2019, change the stucture of the data
#Rename Oto_Selected_aggre


Oto_Selected <- Oto_19 %>% dplyr::select("location", "Genotype" ,"swelling.index", "swelling.power", "WAC"          , "Bulk.Density" )


#taking the average of the genotypes duplicates for otobi
Oto_Selected_aggre <- Oto_Selected %>% group_by(Genotype) %>%
  summarise_if(is.numeric, mean, na.rm = TRUE)

str(Oto_Selected_aggre)


Oto_Selected_aggre$Genotype <- as.factor(Oto_Selected_aggre$Genotype)

#Add columns for years and location
Oto_Selected_aggre  <-  Oto_Selected_aggre  %>%
  add_column(location = "Otobi",year = "2020") # change the year from 2019 to 2020
 
Umu_Selected <- Umu_19 %>% dplyr:: select('Genotype', 'swelling.index', 'swelling.power', 'WAC', 'Bulk.Density') # select the needed columns
 
Umu_Selected  <-  Umu_Selected  %>%
  add_column(location = "Umudike",year = "2020") # add location and year to the data frame

#add otobi and umudike 2019 data 
Umu_oto_19 <- rbind(Oto_Selected_aggre,Umu_Selected)
str(Umu_oto_19)
Umu_oto_19$location <-  as.factor(Umu_oto_19$location)
Umu_oto_19$year <-  as.factor(Umu_oto_19$year)
Umu_oto_19 <- data.frame(Umu_oto_19 )
Umu_oto_19 <-  Umu_oto_19  %>% relocate(location, year) # change the positions of year and location
```

```{r read in 2020_2021 data for Otobi and Umudike}
#read in 2020_2021 data for Otobi and Umudike
Umu_21 <- read.csv(here::here("data", "Umu_2020_2021_PYT_Functional.csv"), head=T) # input genotypes planted in 2020 and harvested in 2021

Oto_21 <- read.csv(here::here("data", "OTOBI_2020_2021_PYT_Functional.csv"), head=T)

dim(Umu_21)
Umu_21$Genotypes <- as.factor(Umu_21$Genotypes)
Umu_21 <- Umu_21 %>% 
       rename(Genotype= Genotypes) # rename Genotypes to genotype
Umu_21 <- Umu_21 %>% 
       rename(swelling.index= Swelling.index)

Umu_21$WAC <- as.numeric(Umu_21$WAC)

Oto_21$Genotype <- as.factor(Oto_21$Genotype)
dim(Oto_21)
```

```{r combining 2021 Umudike and otobi in one data frame and adding year and location}

#combining 2021 Umudike and otobi in one data frame and adding year and location
Umu_21  <-  Umu_21  %>%
  add_column(location = "Umudike",year = "2021") # add year and location to Umu_21
Oto_21  <-  Oto_21  %>%
  add_column(location = "Otobi",year = "2021") # add year and location to oto_21

 Umu_oto_21 <- rbind(Oto_21, Umu_21)# combining the two data frame

 Umu_oto_21 <-  Umu_oto_21 %>% relocate(location, year) # change the position of year and location
 
```

```{r combining all three years}
#combining all three years
pyt_functional <- rbind(Umu_oto_19, Umu_oto_21, Umu_oto_22) # combine all three years
dim(pyt_functional)
pyt_functional <- pyt_functional %>% arrange(location)
pyt_functional = as.data.frame(pyt_functional)
```


```{r using  concanate year and location to be a column called environment}
# create a new column that has Environment to make it look like the data frame in sommer example
#rm(pyt_functional_1)
pyt_functional_1 <- pyt_functional %>%
unite( 'environment', location:year, sep= "_", remove = FALSE) # concantenating location and environment


#summary(wac_model)$varcomp
# pyt_functional_1$environment = gsub(pattern = " ",replacement = "_", x = pyt_functional_1$environment)
#pyt_functional_1$environment = as.factor(pyt_functional_1$environment)

```


```{r editing genotype names in pyt_functional_1$Genotype to match with snp$X and using metan package to change multiple column as factor}

#editing genotype names in pyt_functional_1$Genotype to match with snp$X and using metan package to change multiple column as factor

head(pyt_functional_1)

levels(pyt_functional_1$Genotype)[levels(pyt_functional_1$Genotype) =="TME419"] = "TMEB419" # changing genotype name pattern

levels(pyt_functional_1$Genotype)[levels(pyt_functional_1$Genotype) =="IITA-TMS-1BA30572" ] = "IITA-TMS-IBA30572" # changing genotype name pattern
pyt_functional_1$Genotype = gsub(pattern = " ", replacement = "", x = pyt_functional_1$Genotype) # remove space from the genotype name 


library(metan)
pyt_functional_1 <-  as.data.frame(pyt_functional_1)
pyt_functional_1 <- as_factor(.data = pyt_functional_1, 
                c("environment","location","year","Genotype"))
str(pyt_functional_1)

length(levels(pyt_functional_1$Genotype))
#exm = as_numeric(.data = pyt_functional_1, c("swelling.index","swelling.power","WAC","Bulk.DensIty"))
#str(exm)

write.csv(x = pyt_functional_1$Genotype, file = "pyt_functional_all_years.csv")

```


```{r boxplot using the large data frame }
#boxplot using the large data frame
boxplot
ggplot(data = pyt_functional_1,aes(x=year,y= swelling.index,fill=location)) +
  geom_boxplot() + facet_grid(.~location)

ggplot(data = pyt_functional_1,aes(x=year,y= swelling.power,fill=location)) +
  geom_boxplot()+facet_grid(.~location)

ggplot(data = pyt_functional_1,aes(x=year,y= WAC,fill=location))+
  geom_boxplot()+facet_grid(.~location)

ggplot(data = pyt_functional_1,aes(x=year,y= Bulk.Density,fill=location))+
  geom_boxplot()+facet_grid(.~location)

```


```{r removing outliers for swelling index using the quatile and interquatile ranges}

#removing outliers for swelling index using the quatile and interquatile ranges
quartiles_SI <- quantile(pyt_functional_1$swelling.index, probs=c(.25, .75), na.rm = TRUE) # qualtile for swelling index
IQR_SI <- IQR(pyt_functional_1$swelling.index, na.rm = TRUE) # interquatile range  
 
Lower_SI <- quartiles_SI[1] - 1.5*IQR_SI
Upper_SI <- quartiles_SI[2] + 1.5*IQR_SI
data_no_outlier_SI <- subset(pyt_functional_1, pyt_functional_1$swelling.index > Lower_SI & pyt_functional_1$swelling.index < Upper_SI)
 
dim(data_no_outlier_SI)
ggplot(data = data_no_outlier_SI,aes(x=year,y= swelling.index,fill=location)) +
  geom_boxplot() + facet_grid(.~location)
```

```{r remove outlier for bulk density}
quartiles_WAC <- quantile(pyt_functional_1$WAC, probs=c(.25, .75), na.rm = TRUE) # qualtile for swelling index
IQR_WAC <- IQR(pyt_functional_1$WAC, na.rm = TRUE) # interquatile range  
 
Lower_WAC <- quartiles_WAC[1] - 1.5*IQR_WAC
Upper_WAC <- quartiles_WAC[2] + 1.5*IQR_WAC
 
data_no_outlier_WAC <- subset(pyt_functional_1, pyt_functional_1$WAC > Lower_WAC & pyt_functional_1$WAC < Upper_WAC)
 
dim(data_no_outlier_WAC)

ggplot(data = data_no_outlier_WAC,aes(x=year,y= WAC,fill=location)) +
  geom_boxplot() + facet_grid(.~location)
ggplot(data = pyt_functional_1,aes(x=year,y= WAC,fill=location))+
  geom_boxplot()+facet_grid(.~location)
```

```{r extract each year to get the year information}
#extract each year to get the year information
oto20  <- droplevels(pyt_functional_1[pyt_functional_1$environment == "Otobi_2020",])
oto21  <- droplevels(pyt_functional_1[pyt_functional_1$environment == "Otobi_2021",])
oto22  <- droplevels(pyt_functional_1[pyt_functional_1$environment == "Otobi_2022",])
 
summary(oto20)
summary(oto21)
summary(oto22)

Umu20  <- droplevels(pyt_functional_1[pyt_functional_1$environment == "Umudike_2020",])
Umu21  <- droplevels(pyt_functional_1[pyt_functional_1$environment == "Umudike_2021",])
Umu22  <- droplevels(pyt_functional_1[pyt_functional_1$environment == "Umudike_2022",])

summary(Umu20)
summary(Umu21)
summary(Umu22)

hist(Umu20$Bulk.Density)
hist(Umu21$Bulk.Density)
hist(Umu22$Bulk.Density)
hist(Umu20$Bulk.Density)
```
```{r run linear models for wac}
#dat1 <- droplevels(pyt_functional_1[!is.na(pyt_functional_1$WAC),])
library(lme4)
dim(pyt_functional_1)

```

```{r}
#All_AMYL <-  read.csv(here::here("data/PYT_chemical_data/All_years_amylose.csv"), head=T)
#rm(All_AMYL)
```

```{r, trait correlation}
#trait correlation
corr_functional <-pyt_functional_1[,-c(1:4)]
corr_functional <- corr_functional[,-c(5)]
corr_func <- cor(corr_functional,  use="complete.obs") # correlation
 # correlation
corr_func
pairs(corr_func)

covar_functional  <- cov(corr_functional, use="complete.obs")
covar_functional
write.csv(corr_functional,file=here("./output/correlation_functional_all_year.csv")) 
```

```{r, scatter plots for the covariance of the traits}

plot(pyt_functional_1$WAC ~ pyt_functional_1$Bulk.Density)

plot(pyt_functional_1$WAC ~ pyt_functional_1$swelling.power)

plot(pyt_functional_1[,-c(1:4)])
pairs(covar_functional)
```



```{r, plot the entire trials at the same time, for WAC, SP, SI, Bulk Density}
plot_wac <- pyt_functional_1$environment
pyt_functional_1 %>% 
     ggplot(.,aes(x=WAC, fill=environment))+ geom_density(alpha=0.75)
plot_wac

plot_BD <-pyt_functional_1$environment
pyt_functional_1 %>% 
     ggplot(.,aes(x=Bulk.Density, fill=environment))+ geom_density(alpha=0.75)

plot_BD

plot_sp <- pyt_functional_1$environment
pyt_functional_1 %>% 
     ggplot(.,aes(x=swelling.power, fill=environment))+ geom_density(alpha=0.75)

plot_sp

plot_si <- pyt_functional_1$environment
pyt_functional_1 %>% 
     ggplot(.,aes(x=swelling.index, fill=environment))+ geom_density(alpha=0.75)

plot_si

pyt_functional_1 <- pyt_functional_1 %>% dplyr::rename(Location=location, Year=year)
```

```{r making a function to run the mixed model for all the traits without removing outliers}
# r making a function to run the mixed model for all the traits without removing outliers
traitname<- (c("swelling.index","swelling.power", "WAC", "Bulk.Density")) # matrix of column names

Result.h2org<- matrix(nrow = 1, ncol = length(traitname))
colnames(Result.h2org) <- traitname # naming the colnames of the heritability output so we can identify which trait has that heritability
rownames(Result.h2org) <- "H2Comb" # heritability for the combine analysis
Result.vcomporg = matrix(nrow = length(traitname), ncol = 5) # Result matrix for the variance components
colnames(Result.vcomporg) <- c("vg", "vgl","vgy", "vp","ve") # column names for the variance components
rownames(Result.vcomporg) <- traitname # row names of the variance components
for(trait in traitname){
tr = paste0(trait) # the loop will be able to select  and analyse each trait
Na_g = which(is.na(pyt_functional_1[,tr]))# identify traits with 
if(length(Na_g) == 0){                 # to see if there is any null within the length within the length
DatWithout_na = pyt_functional_1    # if there is no na, it will use the pyt_functional_1 data frame
}else{
DatWithout_na = pyt_functional_1[-Na_g,]  # if there is missing data in the data frame, the use a new dataframe pyt_functional_1[-Na_g,] that has all the na removed
}
 eval(parse(text=paste("model=lmer(formula = ",trait, " ~  Year + Location + Year:Location + (1|Genotype) + (1|Genotype:Year) +(1|Genotype:Location), data = pyt_functional_1)"))) # run the model
 
ss <- summary(model)
sv <- as.data.frame(ss$varcor) # get the variance component
gv <- sv[sv$grp=="Genotype", "vcov"] # genetic variance
gl <- sv[sv$grp == "Genotype:Location" , "vcov"] # genotype by location variance
gy <- sv[sv$grp == "Genotype:Year" , "vcov"] # genotype by year variance
ve <- sv[sv$grp == "Residual" , "vcov"] # residual variance
vph <- gv + gl/2 + gy/3 + ve/6 # variance due to phenotype
# make a matrix of the variance output
H2 <- gv/vph
Result.vcomporg[trait,1] = gv
Result.vcomporg[trait,2] = gl
Result.vcomporg[trait,3] = gy
Result.vcomporg[trait,4] = ve
Result.vcomporg[trait,5] = vph
Result.h2org[,trait] = H2
}
Result.vcomporg
Result.h2org
```


```{r  making a function to run the mixed model for all the traits after removing outliers}
# r  making a function to run the mixed model for all the traits after removing outliers

traitname<- (c("swelling.index","swelling.power", "WAC", "Bulk.Density")) # matrix of column names
Result.h2 = matrix(nrow = 1, ncol = length(traitname)) # this is how we want the result of the heritability to appear after analysis
colnames(Result.h2) <- traitname # naming the colnames of the heritability output so we can identify which trait has that heritability
rownames(Result.h2) <- "H2Comb" # heritability for the combine analysis
Result.vcomp = matrix(nrow = length(traitname), ncol = 5) # Result matrix for the variance components
colnames(Result.vcomp) <- c("vg", "vgl","vgy", "vp","ve") # column names for the variance components
rownames(Result.vcomp) <- traitname # row names of the variance components
for(trait in traitname){
tr = paste0(trait)  # the loop will be able to select  and analyse each trait
Na_g = which(is.na(pyt_functional_1[,tr]))# identify traits with missing data
if(length(Na_g) == 0){                 # to see if there is any null within the length within the length
DatWithout_na = pyt_functional_1    # if there is no na, it will use the pyt_functional_1 data frame
}else{
DatWithout_na = pyt_functional_1[-Na_g,]  # if there is missing data in the data frame, the use a new dataframe pyt_functional_1[-Na_g,] that has all the na removed
}

eval(parse(text=paste("model2=lmer(formula = ",trait, " ~  Year + Location + Year:Location + (1|Genotype) + (1|Genotype:Year) +(1|Genotype:Location), data = DatWithout_na )")))
RES_trait<- rstudent(model2) # i am using the model that used data without missing data
outliers<- which(abs(scale(RES_trait))>3) #Remove outlier
Dat_no_outlier = DatWithout_na[-outliers,] # data frame without outliers
eval(parse(text=paste("model=lmer(formula = ",trait, " ~  Year + Location + Year:Location + (1|Genotype) + (1|Genotype:Year) +(1|Genotype:Location), data = Dat_no_outlier )"))) # run the model
ss <- summary(model)
sv <- as.data.frame(ss$varcor) # get the variance component
sv
gv <- sv[sv$grp=="Genotype", "vcov"] # genetic variance
gl <- sv[sv$grp == "Genotype:Location" , "vcov"] # genotype by location variance
gy <- sv[sv$grp == "Genotype:Year" , "vcov"] # genotype by year variance
ve <- sv[sv$grp == "Residual" , "vcov"] # residual variance
vph <- gv + gl/2 + gy/3 + ve/6 # variance due to phenotype
# make a matrix of the variance output
H2 <- gv/vph
Result.vcomp[trait,1] = gv
Result.vcomp[trait,2] = gl
Result.vcomp[trait,3] = gy
Result.vcomp[trait,4] = ve
Result.vcomp[trait,5] = vph
Result.h2[,trait] = H2
}

Result.vcomp

Result.h2

Result.h2 <- data.frame(Result.h2) # making a data frame for the heritability output
Result.vcomp <- data.frame(Result.vcomp) #making a data frame for the vcomp output
T_h2 <- t(Result.h2) # transpose the heritability output

df_lmer <- cbind(Result.vcomp, T_h2 ) # bind the two data frame
df_lmer 
```

```{r read in the dosage file and modify the row names to match with that in the phenotypic file}
# r read in the dosage file and modify the row names to match with that in the phenotypic file
snps_dosage <- read.csv(here::here("data/snps_199_genotype.csv"), head=T)

dim(snps_dosage)
head(snps_dosage[,1:15])
snps_dosage1 <- (snps_dosage[,-1])
head(snps_dosage1[1:5,1:5])  

mt = rrBLUP::A.mat(snps_dosage1)
heatmap(mt)


#install.packages("FactoMineR")
#library(FactoMineR)
PCA(mt)

genotype_snps <- snps_dosage$X # get the genotype names from the snp dosage file to make it look like the names on the phenotype file

write.csv(genotype_snps,file=here("genotype_snps.csv")) # Had genotype names in new order (NR17C2aF10P011)

```

```{r import the new data frame}
#r import the new data frame
snps_geno_name <- read.csv(here::here("data/genotype_snps.csv"), head=T)  # had genotype names in old order eg (NR17F10C2aP011)

dim(snps_geno_name)
#snps_dosage_N <- sub('IITA.TMS.','IITA-TMS-',geno_snps$X) # To ma sure all the genotypes names are correct . Rewrite the checks

 # combine snps_dosage_N with the dosage file

snps_dosage$X <- snps_geno_name$X # with genotype name in correct order
colnames(snps_dosage)[1] = "geno_name" # rename column 1 of the snps file

rownames(snps_dosage) <- snps_dosage$geno_name # Naming the row names
```

```{r removing missing data from the snps file}
#removing missing data from the snps file
for (j in 1:ncol(snps_dosage)) {
   snps_dosage[, j] <- ifelse(is.na(snps_dosage[, j]), mean(snps_dosage[, j], na.rm = TRUE), snps_dosage[, 
        j])
}

table(rownames(snps_dosage) == pyt_functional_1$Genotype)

table(pyt_functional_1$Genotype == rownames(snps_dosage) )

#snps_dosage1 = snps_dosage[,-1] # remove the column 1 of the snps file
# new_snp <- cbind(geno_name,snps_dosage) # Combine the new and old order genotype names in one data frame.
```

```{r, looking for snps that are not in the phenotype data}
# gen = which(rownames(snps_dosage) %in%pyt_functional_1$Genotype ) # 
# Subset the pheno data that has snp data 
gt = which(pyt_functional_1$Genotype %in% rownames(snps_dosage) ) # identify the row number/genotype name those gentypes from pheno to snps
phen1 = droplevels(pyt_functional_1[gt,]) # subset the pheno data that found in the snp data
head(phen1)
dim(phen1)
dim(pyt_functional_1)
length(rownames(snps_dosage)) # length row name of the snps
length(levels(as.factor(phen1$Genotype))) # the length of the selected pheno data genotype levels 

# if the legnths are equal no need subseting the snp data
# but if the length is different we should subset the snp data in relation to the selected pheno genotypes 
gsnp = which(rownames(snps_dosage) %in% levels(phen1$Genotype)) 

snp2 = snps_dosage[rownames(snps_dosage)[gsnp],] # subset the snps based on the genotypes with snp and also phenotype
dim(snp2)
length(levels(phen1$Genotype))
Geno_present <- rownames(snp2) %in% levels(phen1$Genotype)
```

```{r A matrix  }
library(sommer)
A <- rrBLUP::A.mat(snp2[,-1])
heatmap(A)# heatmap for genotypes present in 194 genotypes
library(factoextra)
A_pca<-prcomp(A, scale=TRUE)

fviz_eig(A_pca) # scree plot of the PCA

```

```{r  mixed model with the new genotype GA data}
mix_wac <- mmer(WAC~ Year + Location+ Year:Location, 
             random=~vsr(Genotype, Gu=A) + Genotype:Year + Genotype:Location,
             rcov=~units,
             data=phen1)

summary(mix_wac)$varcomp

vpredict(mix_wac, h1 ~ V1/(V1+ (V2/3)+ (V3/2)+(V4/6)) ) # heritability for WAC


#Bulk density
mix_BD <- mmer(Bulk.Density~ Year + Location + Year:Location,
             random=~vsr(Genotype, Gu=A)+ Genotype:Year + Genotype:Location,
             rcov=~units,
             data=phen1)
summary(mix_BD)$varcomp
vpredict(mix_BD, h1 ~ V1/((V1)+(V2/3)+(V3/2)+(V4/6)))

#swelling index
mix_si <- mmer(swelling.index~ Year + Location + Year:Location,
             random=~vsr(Genotype, Gu=A)+ Genotype:Year + Genotype:Location,
             rcov=~units,
             data=phen1)
summary(mix_si)$varcomp
vpredict(mix_si, h1 ~ V1/((V1)+(V2/3)+(V3/2)+(V4/6)))


mix_sp <- mmer(swelling.power~ Year + Location + Year:Location,
             random=~vsr(Genotype, Gu=A)+ Genotype:Year + Genotype:Location,
             rcov=~units,
             data=phen1)
summary(mix_sp)$varcomp
vpredict(mix_sp, h1 ~ V1/((V1)+(V2/3)+(V3/2)+(V4/6)))

```


```{r function to loop all mixed models using the GA matrix for all traits}
# function to loop all mixed models using the GA matrix for all traits
traitnames<- (c("swelling.index","swelling.power", "WAC", "Bulk.Density"))
library(sommer)
h2c = tibble() # an empty table that will contain the heritability for all the traits
vcomp = tibble() # an empty table that will contains the variance components
names(vcomp) = c("vg","vgl","vgy","vp","ve")
# h2c = as.data.frame(h2c)
# rownames(h2c) = traitnames
# h2c = tibble(h2c)
for(traits in traitnames){
 trs = paste0(traits) # the loop will be able to select  and analyse each trait
 
eval(parse(text=paste("model1= mmer(",traits,"~ Year + Location + Year:Location,
             random=~vsr(Genotype, Gu=A)+ Genotype:Year + Genotype:Location,
             rcov=~units,
             data=phen1)")))

ss = summary(model1)
ss = data.frame(ss$varcomp)
vg = ss[1,"VarComp"] # assigning names to the variance component in column 1
vgy = ss[2,"VarComp"]
vgl = ss[3,"VarComp"]
ve = ss[4,"VarComp"]
vp =  vg + vgl/2 + vgy/3  + ve/6 
tt = cbind(vg,vgl, vgy, vp, ve)

rownames(tt) = paste(traits) # This will calculate the heritability of each of the traits

vcomp = rbind(vcomp,tt) # this bind the variance components to the functional properties

name = paste0(traits)
h2 = vpredict(model1, ~ V1/(V1 + (V2/3) + (V3/2)+(V4/6)) )
h2 = as.data.frame(h2)
rownames(h2) = paste0(traits)
h2c = rbind(h2c,h2)

}
vcomp
h2c 
```


```{r binding heritability}
df_mmer <- cbind(vcomp,h2c) # binding the mmer variance components with heritability
df_mmer <- data.frame(df_mmer) #converting to a data frame
colnames(df_mmer)[6] <- "h2" # rename Estimates to h2
colnames(df_mmer)[7] <- "SE h2"
View(df_mmer)
df_mmer
```


```{r creating tables}
# creating tables
df_lmer <- cbind(Result.vcomp, T_h2 ) # bind the two data frames

colnames(df_mmer)[6] = "H2Comb"
df_mmer1 = df_mmer[,-7]
rownames(df_mmer1) <- c("swelling.index_mmer", "swelling.power_mmer", "WAC_mmer", "Bulk.Density_mmer")
rownames(df_lmer) <- c("swelling.index_lmer", "swelling.power_lmer", "WAC_lmer", "Bulk.Density_lmer")

lmer_mmer <- rbind(df_lmer, df_mmer1) # bind the two data frames

lmer_mmer

lmer_mmer_sort <- lmer_mmer[sort(rownames(lmer_mmer)),] # sort the lmer_mmer data frame according to the rownames
lmer_mmer_sort
```
```{r merging the functional data with the chemical data}
All_chem <- read.csv(here::here("data/PYT_chemical_data/All_years_chem.csv")) 
dim(All_chem)
which(All_chem$Crude.Fiber > 25)
All_chem[393,"Crude.Fiber"] = NA

#pyt_functional <- pyt_functional %>% dplyr::rename(Location=location, Year=year)
pyt_functional <- pyt_functional %>% dplyr::mutate(combo=paste0(Location, Year, Genotype))
All_chem <- All_chem %>% dplyr::mutate(combo=paste0(Location, Year, Genotype))
str(All_chem)
All_chem <- All_chem[-1,] #remove row 1
All_chem <- All_chem[-1]
str(All_chem)

#All_chem <- All_chem %>% dplyr::mutate(Year_n=as.factor(Year)) %>% dplyr::select(-Year) %>% rename(Year=Year_n)
str(All_chem)

#All_chem <- All_chem %>% dplyr::rename(location=Location, year=Year)
All_chem <- All_chem%>% relocate(Location, Year) # change the position of the location and year
All_chem$Location <- as.factor(All_chem$Location)
All_chem$Year <- as.factor(All_chem$Year)
All_chem$Genotype <- as.factor(All_chem$Genotype)
chem_func <- dplyr::full_join(pyt_functional, All_chem, by=c("Location", "Year", "Genotype"))
# chem_func <- merge(pyt_functional, All_chem, all.x=FALSE)

dim(pyt_functional)
dim(All_chem)
str(chem_func)

levels(chem_func$Genotype)[levels(chem_func$Genotype) =="TME419"] = "TMEB419" # changing genotype name pattern

levels(chem_func$Genotype)[levels(chem_func$Genotype) =="IITA-TMS-1BA30572" ] = "IITA-TMS-IBA30572" # changing genotype name pattern
chem_func$Genotype = gsub(pattern = " ", replacement = "", x = chem_func$Genotype) # remove space from the genotype name
colnames(chem_func)

str(chem_func)
chem_func1 <- chem_func %>% dplyr::select(c("swelling.index","swelling.power","WAC","Bulk.Density","Amylose","Crude.Fiber")) # select only the numeric data
```

```{r importing 2020 starch and sugar for Umudike}
Umu_20_starch_sugar <- read.csv(here::here("data/PYT_chemical_data/UmU_2019_2020_starch_sugar_HCN.csv"))

Umu_20_starch_sugar$Year <- as.factor(Umu_20_starch_sugar$Year)

Umu_20_starch_sugar$Location <- as.factor(Umu_20_starch_sugar$Location)

Umu_20_starch_sugar$Genotype <- as.factor(Umu_20_starch_sugar$Genotype)

Umu_20_starch_sugar <- Umu_20_starch_sugar %>% group_by(Year, Location, Genotype) %>%
  summarise_if(is.numeric, mean, na.rm = TRUE)

Umu_20_starch_sugar <- Umu_20_starch_sugar %>%
  dplyr::select( Year,Location, Genotype, STARCH,SUGAR )

```

```{r, importing 2020 starch and sugar for otobi}
Oto_20_starch_sugar <-read.csv(here::here("data/PYT_chemical_data/Oto_2019_2020_Starch_sugar_HCN.csv"))

Oto_20_starch_sugar$Year <- as.factor(Oto_20_starch_sugar$Year)

Oto_20_starch_sugar$Location <- as.factor(Oto_20_starch_sugar$Location)

Oto_20_starch_sugar$Genotype <- as.factor(Oto_20_starch_sugar$Genotype)

Oto_20_starch_sugar <- Oto_20_starch_sugar %>% group_by(Year, Location, Genotype) %>%
  summarise_if(is.numeric, mean, na.rm = TRUE)

Oto_20_starch_sugar <- Oto_20_starch_sugar %>%
  dplyr::select( Year,Location, Genotype, STARCH,SUGAR)

```

```{r, importing 2021 starch and sugar for Umudike}

Umu_21_starch_garri <- read.csv(here::here("data/PYT_chemical_data/2020_2021_umu_garri_starch_sugar.csv"))

dim(Umu_21_starch_garri)
Umu_21_starch_garri$Year <- as.factor(Umu_21_starch_garri$Year)

Umu_21_starch_garri$Location <- as.factor(Umu_21_starch_garri$Location)

Umu_21_starch_garri$Genotype <- as.factor(Umu_21_starch_garri$Genotype)

```

```{r, importing 2021 starch and sugar for otobi}
Oto_21_starch_garri <- read.csv(here::here("data/PYT_chemical_data/2020_2021_Oto_garri_starch_sugar.csv"))

Oto_21_starch_garri$Year <- as.factor(Oto_21_starch_garri$Year)

Oto_21_starch_garri$Location <- as.factor(Oto_21_starch_garri$Location)

Oto_21_starch_garri$Genotype <- as.factor(Oto_21_starch_garri$Genotype)

```


```{r importing 2022 starch and sugar for Umudike }

Umu_22_starch_sugar <- read.csv(here::here("data/PYT_chemical_data/2022_umu_starch_garri.csv"))

Umu_22_starch_sugar$Year <- as.factor(Umu_22_starch_sugar$Year)

Umu_22_starch_sugar$Location <- as.factor(Umu_22_starch_sugar$Location)

Umu_22_starch_sugar$Genotype <- as.factor(Umu_22_starch_sugar$Genotype)


```


```{r importing 2022 starch and sugar for otobi}

Oto_22_starch_sugar <-read.csv(here::here("data/PYT_chemical_data/2022_Oto_garri_starch_sugar.csv"))

Oto_22_starch_sugar$Year <- as.factor(Oto_22_starch_sugar$Year)

Oto_22_starch_sugar$Location <- as.factor(Oto_22_starch_sugar$Location)

Oto_22_starch_sugar$Genotype <- as.factor(Oto_22_starch_sugar$Genotype)

```

```{r binding all data }

starch_sugar <- rbind(Oto_20_starch_sugar, Oto_21_starch_garri,Oto_22_starch_sugar, Umu_20_starch_sugar, Umu_21_starch_garri,  Umu_22_starch_sugar)

dim(starch_sugar)
str(starch_sugar)
starch_sugar <- as.data.frame(starch_sugar)
```

```{r merging starch and sugar with the previous data. chem-pheno}
library(dplyr)
starch_sugar <- starch_sugar %>% relocate(Location, Year) # change the position of the location and year


chem_pheno <- dplyr::full_join(chem_func2, starch_sugar, by=c("Location", "Year", "Genotype"))

```


```{r clean the new data frame chem_pheno}

levels(chem_pheno$Genotype)[levels(chem_pheno$Genotype) =="TME419"] = "TMEB419" # changing genotype name pattern

levels(chem_pheno$Genotype)[levels(chem_pheno$Genotype) =="IITA-TMS-1BA30572"] = "IITA-TMS-IBA30572" # changing genotype name pattern


chem_pheno$Genotype = gsub(pattern = " ", replacement = "", x = chem_pheno$Genotype) # remove space from the genotype name
chem_pheno$Genotype<- as.factor(chem_pheno$Genotype)

levels(chem_pheno$Genotype)[levels(chem_pheno$Genotype) =="IITA-TMS-1BA00070"] = "IITA-TMS-IBA00070" # changing genotype name pattern

str(chem_pheno)
chem_pheno1 <- chem_pheno %>% dplyr::select(c("swelling.index","swelling.power","WAC","Bulk.Density","Amylose","Crude.Fiber", "STARCH","SUGAR")) # select only the numeric data
```


```{r correlation plot of the chem_func data frame}
library(corrplot)
corr <- cor(chem_pheno1,use = "pairwise.complete.obs")
cor_chem_func <- corrplot(corr, method = "number",type = "upper",order = "alphabet", is.corr = TRUE)
```


```{r box plot of functional with amylose and crude fiber}
#box plot of functional with amylose and crude fiber
chem_func2 <-chem_func %>% dplyr::select(c( "Location","Year","Genotype", "swelling.index","swelling.power","WAC", "Bulk.Density","Amylose","Crude.Fiber"))
chem_func2$Location <- as.factor(chem_func2$Location)
str(chem_func2)
#chem_func2 <- chem_func2[-1,]# remove row 1, it is empty and was created when I sorted my data

ggplot(data = chem_func2,aes(x=Year,y= swelling.index,fill=Location)) +
  geom_boxplot() 
ggplot(data = chem_func2,aes(x=Year,y= swelling.power,fill=Location)) +
  geom_boxplot()

ggplot(data = chem_func2,aes(x=Year,y= WAC,fill=Location))+
  geom_boxplot()

ggplot(data = chem_func2,aes(x=Year,y= Bulk.Density,fill=Location))+
  geom_boxplot()

ggplot(data = chem_func2,aes(x=Year,y=Crude.Fiber,fill=Location))+
  geom_boxplot()

ggplot(data = chem_func2,aes(x=Year,y= Amylose,fill=Location))+
  geom_boxplot()

```

```{r use the data with amylose and crude fiber for the lmer and broad sense heritability removing outliers}
traitname<- (c("swelling.index","swelling.power", "WAC", "Bulk.Density", "Amylose","Crude.Fiber","STARCH","SUGAR")) # matrix of column names
Result.h2 = matrix(nrow = 1, ncol = length(traitname)) # this is how we want the result of the heritability to appear after analysis
colnames(Result.h2) <- traitname # naming the colnames of the heritability output so we can identify which trait has that heritability
rownames(Result.h2) <- "H2Comb" # heritability for the combine analysis
Result.vcomp = matrix(nrow = length(traitname), ncol = 5) # Result matrix for the variance components
colnames(Result.vcomp) <- c("vg", "vgl","vgy", "vp","ve") # column names for the variance components
rownames(Result.vcomp) <- traitname # row names of the variance components
for(trait in traitname){
tr = paste0(trait)  # the loop will be able to select  and analyse each trait
Na_g = which(is.na(chem_pheno[,tr]))# identify traits with missing data
  if(length(Na_g) == 0){                 # to see if there is any null within the length within the length
    DatWithout_na2 = chem_pheno    # if there is no na, it will use the chem_pheno data frame
  }else{
    DatWithout_na2 = chem_pheno[-Na_g,]  # if there is missing data in the data frame, the use a new dataframe chem_func2[-Na_g,] that has all the na removed
  }
eval(parse(text=paste("model3=lmer(formula = ",trait, " ~  Year + Location + Year:Location + (1|Genotype) + (1|Genotype:Year) +(1|Genotype:Location), data = DatWithout_na2 )")))
RES_trait<- rstudent(model3) # i am using the model that used data without missing data
outliers<- which(abs(scale(RES_trait))>3) #Remove outlier
if(length(outliers) == 0){
  Dat_no_outlier2 = DatWithout_na2
}else{
  Dat_no_outlier2 = DatWithout_na2[-outliers,]
}
#Dat_no_outlier2 = DatWithout_na2[-outliers,] # data frame without outliers
eval(parse(text=paste("model=lmer(formula = ",trait, " ~  Year + Location + Year:Location + (1|Genotype) + (1|Genotype:Year) +(1|Genotype:Location), data = Dat_no_outlier2 )"))) # run the model
ss <- summary(model)
sv <- as.data.frame(ss$varcor) # get the variance component
sv
gv <- sv[sv$grp=="Genotype", "vcov"] # genetic variance
gl <- sv[sv$grp == "Genotype:Location" , "vcov"] # genotype by location variance
gy <- sv[sv$grp == "Genotype:Year" , "vcov"] # genotype by year variance
ve <- sv[sv$grp == "Residual" , "vcov"] # residual variance
vph <- gv + gl/2 + gy/3 + ve/6 # variance due to phenotype
# make a matrix of the variance output
H2 <- gv/vph
Result.vcomp[trait,1] = gv
Result.vcomp[trait,2] = gl
Result.vcomp[trait,3] = gy
Result.vcomp[trait,4] = ve
Result.vcomp[trait,5] = vph
Result.h2[,trait] = H2
}

Result.vcomp

Result.h2

Result.h2 <- data.frame(Result.h2) # making a data frame for the heritability output
Result.vcomp <- data.frame(Result.vcomp) #making a data frame for the vcomp output
T_h2 <- t(Result.h2) # transpose the heritability output

df_lmer <- cbind(Result.vcomp, T_h2 ) # bind the two data frame
df_lmer 
```

```{r using data with no outlier to make boxplot}

ggplot(data = Dat_no_outlier2,aes(x=Year,y= swelling.index,fill=Location)) +
   geom_boxplot() 
ggplot(data = Dat_no_outlier2,aes(x=Year,y= swelling.power,fill=Location)) +
  geom_boxplot()
ggplot(data = Dat_no_outlier2,aes(x=Year,y= WAC,fill=Location))+
   geom_boxplot()
ggplot(data = Dat_no_outlier2,aes(x=Year,y= Bulk.Density,fill=Location)) +
  geom_boxplot()
 
ggplot(data = Dat_no_outlier2,aes(x=Year,y= Amylose,fill=Location)) +
  geom_boxplot()

ggplot(data = Dat_no_outlier2,aes(x=Year,y=Crude.Fiber,fill=Location)) +
  geom_boxplot()
 
 
```

```{r}
head(Dat_no_outlier2)

Dat_no_outlier3 <- Dat_no_outlier2 %>%            
  dplyr::rename("SI" = "swelling.index", "SP" = "swelling.power", "BD" = "Bulk.Density", "AMY" = "Amylose", "CF" = "Crude.Fiber", "STA"= "STARCH", "SUG"= "SUGAR")
trait= c("SI","SP", "WAC", "BD", "AMY", "CF", "STR","SUG" )
narrow_Dat_no_outlier <- Dat_no_outlier3 %>%
  gather(key = trait, value = y, -c(Location,Year, Genotype))

boxplot_Dat_no_outlier <- ggplot(data = Dat_no_outlier3, aes(x=Location,y=y, fill=trait)) +
  geom_boxplot( stat = "boxplot",  outlier.colour = "red", outlier.shape = 16, outlier.size = 0.5, na.rm=TRUE) +
  stat_summary(fun=mean, colour="blue", geom="point", na.rm = TRUE) +
  labs(x= "Location", y= "Response values") + theme_bw() +
  theme(axis.title = element_text(colour="black",face="bold", size=10),
        plot.title = element_text(hjust = 0.5,lineheight=.5,colour="black",face="bold", size=9),
        axis.text = element_text(face="bold", size=5), axis.text.x = element_text(angle = 90, hjust = 1),legend.position="none")+
  facet_grid(trait~Year, scales = "free")

boxplot_Dat_no_outlier

```

```{r correlation with data without outlier}

Dat_no_outlier4 <- Dat_no_outlier3 %>%            
  dplyr::select("SP", "WAC", "BD", "AMY", "CF", "STA", "SUG")

#colnames(Dat_no_outlier2) = c("SI", "SP", "WAC", "BD", "AMY", "CF") # Renaming the column sequentially

corr <- cor(Dat_no_outlier4,use = "pairwise.complete.obs")
cor_chemfunc <- corrplot(corr, method = "number",type = "upper",order = "alphabet", is.corr = TRUE)
```



```{r}
#removing missing data
for (j in 1:ncol(snps_dosage)) {
   snps_dosage[, j] <- ifelse(is.na(snps_dosage[, j]), mean(snps_dosage[, j], na.rm = TRUE), snps_dosage[, 
        j])
}

table(rownames(snps_dosage) == Dat_no_outlier3$Genotype)

table(Dat_no_outlier3$Genotype == rownames(snps_dosage) )

#snps_dosage1 = snps_dosage[,-1] # remove the column 1 of the snps file
# new_snp <- cbind(geno_name,snps_dosage) # Combine the new and old order genotype names in one data frame.
```

```{r}
# gen = which(rownames(snps_dosage) %in%pyt_functional_1$Genotype ) # 
# Subset the pheno data that has snp data 
gt2 = which(Dat_no_outlier3$Genotype %in% rownames(snps_dosage) ) # identify the row number/genotype name those gentypes from pheno to snps

phen_new = droplevels(Dat_no_outlier3[gt2,]) # subset the pheno data that found in the snp data

head(phen_new)
dim(phen_new)

length(rownames(snps_dosage)) # length row name of the snps
length(levels(as.factor(phen_new$Genotype))) # the length of the selected pheno data genotype levels 

# if the legnths are equal no need subseting the snp data
# but if the length is different we should subset the snp data in relation to the selected pheno genotypes
library(ASRgenomics)
gsnp2 = which(rownames(snps_dosage) %in% levels(phen_new$Genotype)) 

snp3 = snps_dosage[rownames(snps_dosage)[gsnp2],] # subset the snps based on the genotypes with snp and also phenotype

gph2 = which(phen_new$Genotype %in% rownames(snps_dosage))# looking for phenotype data in snps_dosage file.
phen_new1 = phen_new[gph2, ]
dim(phen_new1)
all(phen_new1$Genotype %in% rownames(snp3))
length(levels(phen_new1$Genotype))
all(rownames(snp3) %in% phen_new1$Genotype)
```

```{r script from moshood to clean up the snps file using the ASRgenomics}
#A1 <- rrBLUP::A.mat(snp2[,-1])
snps_dosage1 <- snps_dosage[,-1]
snps_dosage1 <- as.data.frame(snps_dosage1)
snps_dosage1<- snps_dosage1[,-1]
snps_dosage1<- as.matrix(snps_dosage1)
snpsFilter  <- qc.filtering(M=snps_dosage1, base=FALSE, ref=NULL,
        marker.callrate=0.2,ind.callrate=0.2, maf=0.05,heterozygosity=0.95,
        Fis=1, impute=FALSE,  plots=FALSE,message=FALSE)$M.clean

# compute genomic relationship matrix from filtered SNPS marker
Gmat  <- G.matrix(M = snpsFilter, method = "VanRaden", na.string = NA,message=FALSE)$G

heatmap(Gmat)
# Tuning the G-matrix (Gmat) by bending i.e. adjust it near a positive definite
# by making some of its very small or negative eigenvalues slightly positive (Matrix::nearPD # Bend the Gmat matr
G_bend <- G.tuneup(G=Gmat, bend=TRUE, eig.tol = 1e-06,message=FALSE)$Gb 

# Tuning the G-matrix (Gmat) by blending #
G_blend <- G.tuneup(G=G_bend, blend=TRUE, pblend=0.02,message=FALSE)$Gb

# get the inverse of blend genomic relationship matrix
#kinv <<- G.inverse(G = G_blend, sparseform = TRUE,message = FALSE)$Ginv




#heatmap(A1)# heatmap for genotypes present in 194 genotypes
#install.packages("factoextra")
#library(factoextra)
#A1_pca<-prcomp(A1, scale=TRUE)

#fviz_eig(A1_pca) # scree plot
```


```{r}
traitname<- (c("SI",    "SP",   "WAC",    "BD", "AMY",   "CF",     "STA",    "SUG")) # matrix of column names
Result.h2 = matrix(nrow = 1, ncol = length(traitname)) # this is how we want the result of the heritability to appear after analysis
colnames(Result.h2) <- traitname # naming the colnames of the heritability output so we can identify which trait has that heritability
rownames(Result.h2) <- "H2Comb" # heritability for the combine analysis
Result.vcomp = matrix(nrow = length(traitname), ncol = 5) # Result matrix for the variance components
colnames(Result.vcomp) <- c("vg", "vgl","vgy", "vp","ve") # column names for the variance components
rownames(Result.vcomp) <- traitname # row names of the variance components
for(trait in traitname){
  tr = paste0(trait)  # the loop will be able to select  and analyse each trait
  Na_g = which(is.na(phen_new1[,tr]))# identify traits with missing data
  if(length(Na_g) == 0){                 # to see if there is any null within the length within the length
    DatWithout_na = phen_new1# if there is no na, it will use the pyt_functional_1 data frame
  }else{
    DatWithout_na2 = phen_new1[-Na_g,]  # if there is missing data in the data frame, the use a new dataframe pyt_functional_1[-Na_g,] that has all the na removed
  }
  
  eval(parse(text=paste("model2=lmer(formula = ",trait, " ~  Year + Location + Year:Location + (1|Genotype) + (1|Genotype:Year) +(1|Genotype:Location), data = DatWithout_na2 )")))
  RES_trait<- rstudent(model2) # i am using the model that used data without missing data
  outliers<- which(abs(scale(RES_trait))>3) #Remove outlier
  if(length(outliers) == 0){
  Dat_no_outlier2 = DatWithout_na2
}else{
  Dat_no_outlier2 = DatWithout_na2[-outliers,]
}# data frame without outliers
  eval(parse(text=paste("model=lmer(formula = ",trait, " ~  Year + Location + Year:Location + (1|Genotype) + (1|Genotype:Year) +(1|Genotype:Location), data = Dat_no_outlier2 )"))) # run the model
  ss <- summary(model)
  sv <- as.data.frame(ss$varcor) # get the variance component
  sv
  gv <- sv[sv$grp=="Genotype", "vcov"] # genetic variance
  gl <- sv[sv$grp == "Genotype:Location" , "vcov"] # genotype by location variance
  gy <- sv[sv$grp == "Genotype:Year" , "vcov"] # genotype by year variance
  ve <- sv[sv$grp == "Residual" , "vcov"] # residual variance
  vph <- gv + gl/2 + gy/3 + ve/6 # variance due to phenotype
  # make a matrix of the variance output
  H2 <- gv/vph
  Result.vcomp[trait,1] = gv
  Result.vcomp[trait,2] = gl
  Result.vcomp[trait,3] = gy
  Result.vcomp[trait,4] = ve
  Result.vcomp[trait,5] = vph
  Result.h2[,trait] = H2
}

Result.vcomp

Result.h2

Result.h2 <- data.frame(Result.h2) # making a data frame for the heritability output
Result.vcomp <- data.frame(Result.vcomp) #making a data frame for the vcomp output
T_h2 <- t(Result.h2) # transpose the heritability output

df_lmer <- cbind(Result.vcomp, T_h2 ) # bind the two data frame
df_lmer 
```



#the best data
```{r function to loop all mixed models using the GA matrix for all traits using data without outliers, also made the boxplot of the physicochemical in a loop}
traitnames<- (c("SI","SP", "WAC", "BD", "AMY","CF", "STA", "SUG"))

vcomp = tibble() # an empty table that will contains the variance components

filtered_value <- tibble() # for boxplot
# h2c = as.data.frame(h2c)
# rownames(h2c) = traitnames
# h2c = tibble(h2c)
idm = which(rownames(Gmat) %in% Dat_no_outlier2$Genotype) # which snps are found in phenotype
Gmat1 = Gmat[idm,idm] # subset of The GMat
idg = Dat_no_outlier2$Genotype %in% rownames(Gmat)# phenotype in marker
Dat_no_outlier3 = Dat_no_outlier2[idg,]# row numbers 
all(Dat_no_outlier3$Genotype %in% rownames(Gmat1))# to check if data have both phenotype and genotype
for(traits in traitnames){
 trs = paste0(traits) # the loop will be able to select  and analyse each trait
 out_ind <- which(Dat_no_outlier3[,paste(traits)] %in% boxplot.stats(Dat_no_outlier3[,paste(traits)])$out)

 if(length(out_ind) == 0){
 Data1 = Dat_no_outlier3
 }else{
 Data1 = Dat_no_outlier3[-out_ind,]
 }
 eval(parse(text=paste(
  "model1= mmer(",traits,"~ Year + Location + Year:Location,
  random=~vsr(Genotype, Gu=Gmat1) + Genotype:Year + Genotype:Location,
  rcov=~units,
  data=Data1)")))

summary(model1)
ss = summary(model1)
ss = data.frame(ss$varcomp)
vg = ss[1,"VarComp"] # assigning names to the variance component in column 1
vgy = ss[2,"VarComp"]
vgl = ss[3,"VarComp"]
ve = ss[4,"VarComp"]
vp =  vg + vgl/2 + vgy/3  + ve/6 
h = round(vg/vp,3)
tt = cbind("Trait" = paste(traits), "Method" = "mmer", "vg" = round(vg,3), "vgl" = round(vgl,3), "vgy" = round(vgy,3), "vph" = round(vp,3), "ve" = round(ve,3), "H2" = h)

rownames(tt) = paste(traits) # This will calculate the heritability of each of the traits

## variance comp and h2 for lmer 

eval(parse(text=paste(
  "model2= lmer(",traits,"~ Year + Location + Year:Location + (1|Genotype) + (1|Genotype:Year) + (1|Genotype:Location),
  data=Data1)")))


summary(model2)
ss1 = summary(model2)
ss1 = data.frame(ss1$varcor)
vg1 = ss1[ss1$grp == "Genotype","vcov"] # assigning names to the variance component in column 1
vgy1 = ss1[ss1$grp == "Genotype:Year","vcov"]
vgl1 = ss1[ss1$grp == "Genotype:Location","vcov"]
ve1 = ss1[ss1$grp == "Residual","vcov"] 
vp1 =  vg1 + vgl1/2 + vgy1/3  + ve1/6 
h1 = round(vg1/vp1,3)

tt1 = cbind("Trait" = paste(traits), "Method" ="lmer","vg" = round(vg1,3), "vgl" = round(vgl1), "vgy" = round(vgy1,3), "vph" = round(vp1,3), "ve" = round(ve1,3), H2 = h1)

vccomb = rbind(tt,tt1)
vcomp = rbind(vcomp,vccomb) # this bind the variance components to the functional properties

Bx_1 <- Data1[,traits]
Bx_2 <- cbind(Year=as.character(Data1$Year), Location=as.character(Data1$Location),Geno = as.character(Data1$Genotype), trait=paste0(traits), value=Bx_1)
filtered_value= rbind(filtered_value, Bx_2)
}

# long format
vcomp
h2c 
filtered_value$value=as.numeric(filtered_value$value)
ggplot(filtered_value, aes(x = Location, y=value, fill=Location))+
  geom_boxplot() +
  facet_grid(trait~Year,  scales = "free")

write.csv(x =vcomp, file = "~/Documents/ChinedoziRepo/GarriQuality/output/Heritability_lmer_mmer.csv")

filtered_value$value = as.numeric(filtered_value$value)
ddd = dcast(data = filtered_value, formula = Year + Location + Geno ~ trait, fun.aggregate = mean, value.var = "value", na.rm= T) # mean of the genotypes across location and years
indv_cor <- round(cor(ddd[, -c(1,2,3)],use = "pairwise.complete.obs"),3)
corrplot(indv_cor, type = "upper",method = "number", number.digits = 3, is.corr = T)



write.csv(x =vcomp, file = "~/Documents/ChinedoziRepo/GarriQuality/output/Variance _comp_heritability.csv")


#mean trait corr
#genomean  = dcast(data = filtered_value, formula = Geno ~ trait, fun.aggregate = mean, value.var = "value", na.rm= T)
#geno_cor <- cor(genomean[, -c(1)],use = "pairwise.complete.obs")

```

```{r, genomic prediction for the chemical_functional properties of garri}
set.seed(123)
Acc_pred <- tibble()
traits<- (c("SI","SP", "WAC", "BD", "AMY","CF", "STA", "SUG"))

library(emmeans)
library(lme4)
mean_Data1<- tibble()
for(Trait in traits){
  eval(parse(text = paste("ansm <- lmer(",Trait,"~ (Genotype) + Location +
    (1|Year) ,
      data= Data1)")))
  em = emmeans(object = ansm, specs = ~ Genotype)
  em = as.data.frame(em)
  m2 = cbind(Trait = paste(Trait), em[,1:2])
  mean_Data1 = rbind(mean_Data1,m2)

}

library(reshape)
Meanwide <-dcast(data = mean_Data1, formula = Genotype ~ Trait, fun.aggregate = mean,
                 value.var = "emmean")
#mean_Data1 <- Data1%>% group_by(Genotype) %>%
#summarise_if(is.numeric, mean, na.rm = TRUE)

for(Trait in traits) {
  # Creating a folder that contain 5 subset with 5times with a total of 5*5*8(traits)= 200
  fold5 = caret::createMultiFolds(y = unique(Meanwide$Genotype), k = 5, times = 5)


  for(i in 1:length(fold5)){
    index = fold5[[i]] # the index of the sample for training set
    #subset the phenotypic data
    train_geno <- droplevels(unique(Meanwide$Genotype)[index])
    train_geno_ind <- which(Meanwide$Genotype %in% train_geno)
    train.data <- droplevels(Meanwide %>%
                               filter(row_number() %in% train_geno_ind)) # subset the training set
    dim(train.data)
    test.data <- droplevels(Meanwide %>%
                              filter(!row_number() %in% train_geno_ind)) # subset the testing set
    dim(test.data)
    test.data1 <- test.data
    test.data[,traits] = NA # change the grain yield of the training set to NA value

    mod_dat <- rbind(train.data, test.data) # combine the the data set for analysis

    #####################


    eval(parse(text = paste("ans4 <- mmer(",Trait,"~1,
  random=~vsr(Genotype, Gu=Gmat1),
      rcov=~units,
      data= mod_dat)")))

    pblub = as.data.frame(ans4$U$`u:Genotype`)
    pblub = cbind(rownames(pblub),pblub)
    colnames(pblub)[1] = "Genotype"
    testind = which(pblub$Genotype %in% unique(test.data$Genotype))
    testpred = pblub[testind,]
    testpred$Genotype %in% unique(test.data$Genotype)
    testpred = testpred[order(testpred$Genotype),]

    obs_test =  test.data1 %>% group_by(Genotype) %>%
      summarise_at(.vars = Trait, .funs = mean)
    obs_test= obs_test[order(obs_test$Genotype),]
    r = cbind( Trait, predictability = round(cor(testpred[,Trait],obs_test[,Trait], use = "pairwise.complete.obs"),3))
    colnames(r)[2] <- c("predictability")
    Acc_pred = rbind(Acc_pred,r)


  }
}
#}
Acc_pred$predictability= as.numeric(Acc_pred$predictability)
ggplot(Acc_pred, mapping = aes(x = Trait, y = predictability, fill = Trait)) +
  geom_boxplot() + theme_bw()



ggplot()

```



